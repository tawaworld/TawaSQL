package world.tawa.tawajdbc.dao;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import world.tawa.tawajdbc.*;
import world.tawa.tawajdbc.connection.ConnectionManager;
import world.tawa.tawajdbc.util.DumpUtil;
import world.tawa.tawajdbc.util.JdbcUtil;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Created by tawa on 2018-12-15
 */
public abstract class BaseDAO {
    //
    private static Logger logger = LoggerFactory.getLogger(BaseDAO.class);
    //
    private String dataSourceIndex; // Master-Slave
    //
    private static final long SLOW_SQL_MIN_SPEND_TIME = 1000; // 1s

    protected String getDatasourceIndex() {
        return dataSourceIndex;
    }

    //
    protected void setDatasourceIndex(String dataSourceIndex) {
        this.dataSourceIndex = dataSourceIndex;
    }

    protected int executeUpdate(String sql, Object... parameters) {
        return executeUpdate0(sql, false, parameters);
    }

    protected int[] executeBatch(String sql, List<Object[]> parameters) {
        return executeBatch0(sql, parameters);
    }

    protected <T> T queryForObject(String sql, ResultSetHandler<T> handler, Object... parameters) {
        return queryForObject0(sql, handler, parameters);

    }

    protected <T> List<T> queryForList(String sql, ResultSetHandler<T> handler, Object... parameters) {
        return queryForList0(sql, handler, parameters);
    }


    private int executeUpdate0(String sql, boolean returnAutoGeneratedKeys, Object... parameters) {
        int result = -1;
        long startTime = System.currentTimeMillis();
        long spendTime = 0;
        boolean isException = false;
        try {
            beforeExecute(sql, parameters);
            Connection conn = ConnectionManager.getConnection(dataSourceIndex);
            PreparedStatement ps = conn.prepareStatement(sql, returnAutoGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS);
            int index = 1;
            if (parameters != null) {
                for (Object parameter : parameters) {
                    ps.setObject(index++, parameter);
                }
            }
            result = executeUpdate00(ps, returnAutoGeneratedKeys);
            spendTime = System.currentTimeMillis() - startTime;
            return result;
        } catch (Throwable t) {
            isException = true;
            logger.error(t.getMessage(), t);
            throw new TawaJdbcException(t.getMessage(), t);
        } finally {
            if (logger.isInfoEnabled()) {
                logger.info("executeUpdate \nisException:{} \nspendTime:{}ms \nresult:{} \nparameters:{}\n{}"
                        , isException, spendTime, result, parameters == null ? 0 : parameters.length, DumpUtil.dump(parameters));
            }
            afterExecute(sql, parameters);
            DBStat.executeStat(sql, spendTime, isException);
            if (isException || spendTime >= SLOW_SQL_MIN_SPEND_TIME) {
                logger.warn("executeUpdate \nspendTime:{}ms \nsql:{} \nparameters:{}\n{} "
                        , spendTime, sql, parameters == null ? 0 : parameters.length, DumpUtil.dump(parameters));
            }
        }
    }

    private int executeUpdate00(PreparedStatement ps, boolean returnAutoGeneratedKeys) throws SQLException {
        ResultSet rs = null;
        int rowCount = ps.executeUpdate();
        try {
            if (returnAutoGeneratedKeys) {
                int autoIncrease = -1;
                rs = ps.getGeneratedKeys();
                if (rs.next()) {
                    autoIncrease = rs.getInt(1);
                }
                return autoIncrease;
            }
            return rowCount;
        } catch (SQLException e) {
            throw e;
        } finally {
            JdbcUtil.closeStatementAndResultSet(ps, rs);
        }

    }

    private int[] executeBatch0(String sql, List<Object[]> parameters) {
        int[] result = null;
        long startTime = System.currentTimeMillis();
        long spendTime = 0;
        boolean isException = false;
        try {
            Connection conn = ConnectionManager.getConnection(dataSourceIndex);
            PreparedStatement ps = conn.prepareStatement(sql);
            if (parameters != null) {
                for (Object[] parameterArray : parameters) {
                    int index = 1;
                    for (Object parameter : parameterArray) {
                        ps.setObject(index++, parameter);
                    }
                    ps.addBatch();
                }
            }
            beforeExecute(sql, parameters);
            result = executeBatch00(ps);
            spendTime = System.currentTimeMillis() - startTime;
            return result;
        } catch (Throwable t) {
            isException = true;
            logger.error(t.getMessage(), t);
            throw new TawaJdbcException(t.getMessage(), t);
        } finally {
            if (logger.isInfoEnabled()) {
                logger.info("executeBatch \nisException:{} \nspendTime:{}ms \n result:{} \nsql:{} \nparameters:{}\n{}"
                        , isException, spendTime, result, sql, parameters == null ? 0 : parameters.size(), DumpUtil.dump(parameters));
            }
            afterExecute(sql, parameters);
            DBStat.executeStat(sql, spendTime, isException); //stat
            if (isException || spendTime >= SLOW_SQL_MIN_SPEND_TIME) {
                logger.warn("executeBatch \nspendTime:{}ms \nresult:{} \nsql:{} \nparameters:{}\n{}"
                        , spendTime, result, sql, parameters == null ? 0 : parameters.size(), DumpUtil.dump(parameters));
            }
        }
    }

    private int[] executeBatch00(PreparedStatement ps) throws SQLException {
        try {
            return ps.executeBatch();
        } catch (SQLException e) {
            throw e;
        } finally {
            JdbcUtil.closeStatement(ps);
        }
    }

    private <T> T queryForObject0(String sql, ResultSetHandler<T> handler, Object... parameters) {
        T bean = null;
        boolean isException = false;
        long startTime = System.currentTimeMillis();
        long spendTime = 0;
        try {
            Connection conn = ConnectionManager.getConnection(dataSourceIndex);
            PreparedStatement ps = conn.prepareStatement(sql);
            int index = 1;
            for (Object parameter : parameters) {
                ps.setObject(index++, parameter);
            }
            beforeExecute(sql, parameters);
            bean = query(ps, handler);
            spendTime = System.currentTimeMillis() - startTime;
            return bean;
        } catch (Throwable t) {
            isException = true;
            logger.error(t.getMessage(), t);
            throw new TawaJdbcException(t.getMessage(), t);
        } finally {
            if (logger.isDebugEnabled()) {
                logger.debug("query \nisException:{} \nspendTime:{} \nsql:{} \nparameters:{}\n{}"
                        , isException, spendTime, sql, parameters == null ? 0 : parameters.length, DumpUtil.dump(parameters));
            }
            afterExecute(sql, parameters);
            DBStat.executeStat(sql, spendTime, isException); //stat
            if (isException || spendTime >= SLOW_SQL_MIN_SPEND_TIME) {
                logger.warn("query \nisException:{} \nspendTime:{} \nsql:{} \nparameters:{}\n{}"
                        , isException, spendTime, sql, parameters == null ? 0 : parameters.length, DumpUtil.dump(parameters));
            }
        }
    }

    private <T> T query(PreparedStatement ps, ResultSetHandler<T> handler) throws Exception {
        ResultSet rs = null;
        try {
            rs = ps.executeQuery();
            if (rs != null && rs.next()) {
                return handler.handlerRow(rs);
            }
            return null;
        } catch (Exception e) {
            throw e;
        } finally {
            JdbcUtil.closeStatementAndResultSet(ps, rs);
        }
    }

    private <T> List<T> queryForList0(String sql, ResultSetHandler<T> handler, Object... parameters) {
        List<T> list = null;
        boolean isException = false;
        long startTime = System.currentTimeMillis();
        long spendTime = 0;
        try {
            Connection conn = ConnectionManager.getConnection(dataSourceIndex);
            PreparedStatement ps = conn.prepareStatement(sql);
            int index = 1;
            for (Object parameter : parameters) {
                ps.setObject(index++, parameter);
            }
            beforeExecute(sql, parameters);
            list = queryList(ps, handler);
            spendTime = System.currentTimeMillis();
            return list;
        } catch (Throwable t) {
            isException = true;
            logger.error(t.getMessage(), t);
            throw new TawaJdbcException(t.getMessage(), t);
        } finally {
            if (logger.isDebugEnabled()) {
                logger.debug("query \nisException:{} \nspendTime:{} \nsql:{} \nparameters:{}\n{} \nresultCount:{}"
                        , isException, spendTime, sql, parameters == null ? 0 : parameters.length
                        , DumpUtil.dump(parameters), list == null ? 0 : list.size());
            }
            afterExecute(sql, parameters);
            DBStat.executeStat(sql, spendTime, isException); //stat
            if (isException || spendTime >= SLOW_SQL_MIN_SPEND_TIME) {
                logger.warn("query \nisException:{} \nspendTime:{} \nsql:{} \nparameters:{}\n{} \nresultCount:{}"
                        , isException, spendTime, sql, parameters == null ? 0 : parameters.length
                        , DumpUtil.dump(parameters), list == null ? 0 : list.size());
            }
        }
    }

    private <T> List<T> queryList(PreparedStatement ps, ResultSetHandler<T> handler) throws Exception {
        ResultSet rs = null;
        List<T> list = new ArrayList<>();
        try {
            rs = ps.executeQuery();
            if (rs != null) {
                while (rs.next()) {
                    list.add(handler.handlerRow(rs));
                }
            }
            return list;
        } catch (Exception e) {
            throw e;
        }
    }

    /**
     * before execute interceptor
     */
    private void beforeExecute(String sql, Object... parameters) {
        for (SqlInterceptor sqlInterceptor : Config.getSqlInterceptors()) {
            sqlInterceptor.beforeExecute(sql, parameters);
        }
    }

    /**
     * after execute interceptor
     */
    private void afterExecute(String sql, Object... parameters) {
        for (SqlInterceptor sqlInterceptor : Config.getSqlInterceptors()) {
            sqlInterceptor.afterExecute(sql, parameters);
        }
    }

}
